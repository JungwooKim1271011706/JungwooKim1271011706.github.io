---
title: 자바 - 11(상속)
category:
- Java
tag:
- Java
---

&nbsp;&nbsp;&nbsp;&nbsp;상속은 부모클래스의 자원을 자식클래스에서 사용할 수 있는 객체지향의 프로그래밍 기법 중 하나이다. 상속을 사용하면 코드의 중복 없이 부모클래스의 자원을 자식클래스에서 재사용할 수 있다. 상속의 모습은 다음과 같다.   

    public class A extends B{}

&nbsp;&nbsp;&nbsp;&nbsp;자바는 단일 상속을 기본으로 한다. 따라서 extends 뒤에는 부모클래스 1개만 올 수 있다. 이러면 자식클래스인 A는 부모클래스인 B의 자원을 사용할 수 있다. 자원을 사용하려면 자식클래스를 new 연산으로 인스턴스한다.  

    A a = new A();

&nbsp;&nbsp;&nbsp;&nbsp;자식클래스의 참조변수를 선언하고 new 연산을 하면 먼저 자식클래스를 찾아서 인스턴스한다. 인스턴스하고자 하는 자식클래스가 상속관계에 있으면 부모클래스의 생성자를 먼저 찾아서 메모리에 올리고, 그 후에 자식클래스의 생성자를 메모리에 올린다. 이제 참조변수 a로 부모클래스인 B의 자원을 호출할 수 있다. 참조변수 a로 자원을 먼저 찾아보고, a에 자원이 없다면 부모클래스에 자원을 찾는다. 따라서 자식클래스의 자원이 aa가 있고, 부모클래스의 자원도 aa가 있다면, 자식클래스의 자원 aa를 우선순위로 찾고 호출작업을 종료한다.  
&nbsp;&nbsp;&nbsp;&nbsp;위와 같이 부모클래스의 자원을 가져와 자식클래스에서 재정의할 수도 있다. 이러한 행위를 오버라이딩이라고 한다. 오버라이딩을 하는 경우에는 함수 위에 @Overide 라고 명시적으로 표시해야 한다. 아니면 해당 자원을 상속을 했는지, 직접 자식클래스에서 정의해서 사용하고 있는지 혼란스러운 상황이 발생할 수 있다. 자바에서 @문자열을 쓰는 것을 어노테이션(annotation)이라고 한다.      
&nbsp;&nbsp;&nbsp;&nbsp;지금까지의 내용은 일반적인 클래스의 상속이다. 자바에서는 이러한 상속 외에 추상 클래스의 상속이나 인터페이스 상속이 존재한다. 추상 클래스와 인터페이스가 하는 역할은 동일하다. 규격을 명시적으로 표현하고 규제를 가하는 것이라고 할 수 있다. 어떤 객체가 특정한 추상 클래스 혹은 인터페이스를 사용한다고 할 때, 그 객체는 반드시 인터페이스, 혹은 추상 클래스의 메소드를 구현해야만 한다. 강제하고 있는 메소드를 구현하지 않는 경우에는 컴파일되지 않는다.   
&nbsp;&nbsp;&nbsp;&nbsp;추상 클래스와 인터페이스의 사용법은 다음과 같다.

    추상클래스 : 
    public class A extends B{ //단일 상속이다.
        @override
         bb(){구현부 정의}
    }

    abstract class B{
        bb(); // 구현부 없음 >> 자식클래스의 자원 사용을 강제한다.
    }

    인터페이스 :
    public class A implements B, C{ // 다중 상속 가능

        @override
        b(){구현구 정의} >> 필요조건 

        @override
        c(){구현부 정의} >> 필요조건
    }

    interface B{b()} >> 자식클래스의 자원 사용을 강제한다.

    interface C{c()} >> 자식클래스의 자원 사용을 강제한다.

&nbsp;&nbsp;&nbsp;&nbsp;추상 클래스와 인터페이스 모두 내부에 함수를 정의하는데 구현부가 없다.(자바 1.8부터는 dafault로 인터페이스 내부에서 구현부가 있는 함수를 만들 수 있으나 지양한다) 구현부는 상속을 받는 자식클래스에서 구현해야만 하며, 구현하지 않으면 컴파일 에러가 난다. 일반적으로 추상 클래스의 상위격이 인터페이스의 개념이기 때문에 추상클래스는 사용하지 않고 인터페이스를 사용한다. 인터페이스는 상호간의 약속이기때문에 접근제어자가 기본값으로 public이 되어 있다. 누구든지 사용할 수 있어야 하기 때문이다.    
&nbsp;&nbsp;&nbsp;&nbsp;상속관계에서 자원을 사용하는 경우 클래스 상속과 인터페이스 상속은 사용법이 조금 다르다. 클래스 상속은 자식클래스의 참조변수로 부모의 자원을 활용한다.   
 - 자식클래스 선언 자식참조변수 선언 = new 자식클래스();
 - 이후 자식클래스의 참조변수로 자식/부모의 자원을 사용함
&nbsp;&nbsp;&nbsp;&nbsp;하지만 인터페이스 상속의 경우는 부모클래스를 선언하나, 자식클래스를 인스턴스한다.   
 - 부모클래스 선언 부모자식변수 선언 = new 자식클래스();

&nbsp;&nbsp;&nbsp;&nbsp;이렇게 사용하는 이유가 다형성때문이라고 하는데, 정확히 다형성이 어떤 개념인지 모르겠다. 왜 부모클래스의 참조변수를 가지고 하는걸까...참조변수의 데이터타입이 부모클래스니까 부모클래스의 자원만 사용하고, 그 사용 범위를 제한해서 코드의 가독성을 높이게 하는 것이라면 이해하겠지만, 그건 아닌 것 같다. 좀 더 깊이있게 공부한 다음에 글을 수정할 예정이다.

&nbsp;&nbsp;&nbsp;&nbsp;상속과 연관된 함수 및 키워드 중에서 this/super가 있다. 각각 기능은 다음과 같다.

 - this() : 같은 클래스에서 오버로딩된 다른 생성자를 호출한다.
 - this : 인스턴스한 자기 자신의 주소값을 가리킨다.
 - super() : 부모 클래스의 생성자를 호출한다.
 - super : 인스턴스한 부모의 주소값을 호출한다. 이를 이용해 자식클래스의 자원을 호출해도 부모클래스의
 자원이 있으면 부모클래스의 자원을 호출하고 종료한다.

&nbsp;&nbsp;&nbsp;&nbsp;super()의 경우 부모클래스의 생성자를 호출한다. 하지만 언제든지 호출할 수 있는건 아니다. 부모클래스의 생성자는 자식이 초기화되기 전에 발생해야만 한다. 상속관계에서 자식을 인스턴스하면 부모가 먼저 메모리에 올라간다. 즉, 부모클래스의 자원이 먼저 올라가고 나중에 자식클래스의 자원이 올라간다. 따라서 super()가 사용되는 자리는 자식클래스의 생성자 첫번째 줄로 고정이다. 못움직인다.    
&nbsp;&nbsp;&nbsp;&nbsp;또한, 기본적으로 생성자는 기본 생성자를 JVM이 만들어준다. 그렇다면 super()를 통해서도 가능한가 싶어서 테스트해보니 정상적으로 super()를 통해서 부모클래스의 생성자를 불러왔다. 하지만 일반적인 클래스에서 생성자를 1개라도 정의하는 경우, 그리고 그 생성자가 기본 생성자가 아닌 경우에는 JVM이 기본 생성자를 따로 만들어주지는 않는다. 따라서 생성자를 오버로딩하는 경우에는 꼭 기본 생성자를 정의해줘야 한다.  
&nbsp;&nbsp;&nbsp;&nbsp;정리하면, this()와 super()는 자기 자신, 혹은 부모의 생성자를 호출하며, 생성자의 가장 첫줄에 위치해야만 한다. this와 super는 각각 자식 주소값과 부모 주소값을 가리키는 것 같다. 하지만 this는 홀로 사용도 가능해서 주소값을 출력받을 수 있으나 super는 출력이 불가능하다. super는 자원과 같이 사용해서 부모의 자원을 호출할 수 있다.